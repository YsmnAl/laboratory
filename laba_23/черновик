#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    int key;
    int count;
    struct node **son;
} node;

node *make_node(int x)
{
    node *n = (node *)malloc(sizeof(node));
    n->key = x;
    n->count = 0;
    n->son = NULL;
    return n;
}
node *find_node(node *n, int key)
{
    if (n->key == key)
    {
        return n;
    }
    if (n->count > 0)
    {
        for (int i = 0; n->count > i; ++i)
        {
            node *k = find_node(n->son[i], key);
            if (k != NULL)
            {
                return k;
            }
        }
        return NULL;
    }
    else
    {
        return NULL;
    }
}
void add_node(node *n, int x, int fk)
{
    if (find_node(n, x))
    {
        printf("Exists\n");
    }
    else
    {
        node *s = find_node(n, fk); //отец
        if (s != NULL)              //если отец есть
        {
            if (s->count > 0) //есть сыновья :)
            {
                s->son = (node **)realloc(s->son, (s->count + 1) * sizeof(node *)); //расширили место, чтобы сын влез
                s->son[s->count] = make_node(x);                                    //создали сына
                s->count++;                                                         //посчитали сына
            }
            else if (s->count == 0) //нет сыновей :(
            {
                s->son = (node **)malloc(sizeof(node *)); //создали место для сына
                s->son[0] = make_node(x);                 //создали сына
                s->count++;                               //посчитали сына
            }
        }
        else
        {
            printf("Not found\n");
        }
    }
}
void free_node(node *n)
{
    for (int i = 0; n->count > i; ++i) //смотрим всех сыновей
    {
        if (n->son[i] != NULL) //если сын не пуст, вызываем эту же функцию
        {
            free_node(n->son[i]);
        }
    }
    free(n);
    n = NULL;
}
node *find_father(node *n, int key)
{
    if (n->count > 0)
    {
        for (int i = 0; n->count > i; i++)
        {
            if (n->son[i]->key == key)
            {
                return n;
            }
            else
            {
                node *p = find_father(n->son[i], key);
                if (p != NULL)
                {
                    return p;
                }
            }
        }
        return NULL;
    }
    else
    {
        return NULL;
    }
}
void delete_node(node *n, int key)
{
    node *s = find_node(n, key);
    node *f = find_father(n, key);
    int number;
    for (int i = 0; f->count > i; i++)
    {
        if (f->son[i]->key == key)
        {
            number = i;
            break;
        }
    }
    free_node(s);
    for (int i = number; f->count - 1 > i; i++)
    {
        f->son[i] = f->son[i + 1];
    }
    f->count--;
}
void print_node(node *n, int dep) //все для вывода дерева, рисуем заодно эти палочки между узлами, чтобы красиво было :с
{
    for (int i = 0; dep > i; i++)
    {
        if (i < dep - 1)
        {
            printf(" ");
        }
        else
        {
            printf("|>");
        }
    }
    printf("%d", n->key);
    printf("\n");
    dep++;
    for (int i = 0; n->count > i; i++)
    {
        int depth = dep;
        print_node(n->son[i], depth);
    }
}

void print_tree(node *n)
{
    print_node(n, 0);
}

void print_menu()
{
    printf("What do you want to do?\n");
    printf("\n");
    printf("1 | Add node                           |\n");
    printf("2 | Delete node                        |\n");
    printf("3 | Tree's visualisation               |\n");
    printf("4 | Check the monotony of tree's width |\n");
    printf("5 | Exit                               |\n");
    printf(">");
}
int get_variant(int c)
{
    int var;
    char s[100];    // строка для считывания введённых данных
    scanf("%s", s); // считываем строку

    // пока ввод некорректен, сообщаем об этом и просим повторить его
    while (sscanf(s, "%d", &var) != 1 || var < 1 || var > c)
    {
        printf("Incorrect input. Try again: "); // выводим сообщение об ошибке
        scanf("%s", s);                         // считываем строку повторно
    }
    return var;
}
/* int monotony(node *n, int min)
{
    int c = 0;
    int k = 0;
    for (int i = 0; n->count > i; i++)
    {
        k += n->son[i]->count;
    }
    if (k >= min)
    {
        min = k;
        for (int i = 0; n->count > i; i++)
        {
        }
    }
    else
    {
        return 1;
    }
} */

int main()
{
    int k;
    int tree_ex = 0;
    int father = 0;
    int key = 0;
    int var;
    int top;
    int min;
    node *n = NULL; //дерево
    do
    {
        print_menu();
        char c[100] = "";
        var = get_variant(5); // получаем номер выбранного пункта меню
        switch (var)
        {
        case 1:
            if (tree_ex == 1)
            {
                printf("%s", "Enter father: ");
                scanf("%s", c);
                father = atoi(c); //из чара в инт
                printf("%s", "Enter it's new key value: ");
                scanf("%s", c);
                key = atoi(c);
            }
            else
            {
                printf("%s\n", "Enter father:");
                scanf("%s", c);
                key = atoi(c);
            }
            printf("\n");
            if (tree_ex == 0)
            {
                n = make_node(key);
                tree_ex = 1;
                printf("%s\n", "Added. Tree:");
                printf("\n");
                print_tree(n);
                printf("\n");
            }
            printf("\n");
            if (find_node(n, father))
            {
                if (find_node(n, key))
                {
                    printf("%s\n", "This key already exists");
                }
                else
                {
                    add_node(n, key, father);
                    printf("%s\n", "Added. Tree:");
                    printf("\n");
                    print_tree(n);
                    tree_ex = 1;
                }
            }
            else
            {
                printf("%s\n", "No such parent was found");
            }
            printf("\n");
            break;
        case 2:
            if (tree_ex == 0)
            {
                printf("Tree is empty\n");
                printf("\n");
                continue;
            }
            printf("%s\n", "Select key: ");
            scanf("%s", c);
            k = atoi(c);
            printf("\n");
            if (find_node(n, k) && k != n->key)
            {
                delete_node(n, k);
                printf("%s\n", "Now tree looks like this:");
                printf("\n");
                print_tree(n);
            }
            else if (k == n->key)
            {
                free_node(n);
                tree_ex = 0;
                printf("%s\n", "Tree was deleted");
            }
            else
            {
                printf("%s\n", "No node with such key was found");
            }
            printf("\n");

        case 3:
            printf("%s\n", "Tree:");
            printf("\n");
            if (tree_ex == 1)
            {
                print_tree(n);
            }
            else
            {
                printf("Tree is empty\n");
            }
            printf("\n");

        case 4:
            if (tree_ex == 0)
            {
                printf("Tree is empty\n");
            }
            else
            {
                min = n->count;
            }
            break;
        }
    } while (var != 5);
    return 0;
}
